---
description: 
globs: 
alwaysApply: true
---
# Code Standards for New Features and Commands

## Overview
This document defines the code structure and standards that must be followed when implementing new features and commands in the project. These standards are based on the gold source files in the codebase.

## Command Implementation Standards
When implementing a new command, follow the structure defined in `DevContainerComposer/compose/commands/expose.py`:

1. **File Structure**
   - Place all command files in `DevContainerComposer/compose/commands/`
   - Name the file according to the command (e.g., `expose.py` for expose command)

2. **Import Section**
   - Group imports in this order:
     1. Standard library imports (pathlib, typing)
     2. Third-party imports (typer)
     3. Local imports (from ..models)
   - Use absolute imports for local modules

3. **Validation Functions**
   - Create separate validation function for each parameter
   - Name format: `validate_{parameter_name}`
   - Must accept Optional[T] and return Optional[T] where T is the parameter type
   - Must handle None case
   - Must raise typer.BadParameter for invalid values
   - Must include docstring explaining validation rules

4. **Option Definitions**
   - Define as module-level constants
   - Name format: `{parameter_name}_option`
   - Use typer.Option with:
     - Default value (usually None)
     - Flag name (--parameter-name)
     - Help text
     - Validation callback

5. **Command Function**
   - Must be named `command`
   - First parameter must be `ctx: typer.Context`
   - All parameters must have type hints
   - Use defined options as default values
   - Must include docstring
   - Must implement try/except block
   - Must use typer.echo for error messages
   - Must exit with typer.Exit(1) on errors

6. **Error Handling**
   - Use typer.BadParameter for validation errors
   - Use try/except for runtime errors
   - Always provide meaningful error messages
   - Exit with appropriate status codes

7. **Documentation**
   - Include docstrings for all functions
   - Document parameters and return values
   - Explain validation rules
   - Provide usage examples in docstrings

## Model Implementation Standards
When implementing a new model, follow the structure defined in `DevContainerComposer/compose/models.py`:

### Feature Models
For models that represent specific features in the devcontainer configuration:
- Model class must inherit from `Feature` base class (which itself inherits from Pydantic's BaseModel)
- Use Pydantic Field for model attributes
- Implement required methods:
  - `compose()` method that returns Dict
- Use proper type hints and annotations
- Include comprehensive docstrings
- Follow the established validation patterns

### General Models
For other models that don't represent features:
- Use Pydantic's BaseModel directly
- Use Pydantic Field for model attributes
- Use proper type hints and annotations
- Include comprehensive docstrings
- Follow the established validation patterns

## Test Implementation Standards
### Command Tests
When writing tests for commands, follow the structure in `DevContainerComposer/tests/commands/test_expose.py`:

1. **Test Structure**
   - Test class must use pytest
   - Use CliRunner for command testing
   - Test both success and failure cases
   - Test error handling

2. **Fixtures Usage**
   - MUST use fixtures defined in `conftest.py` when available
   - Do not recreate fixtures that already exist in `conftest.py`
   - Only create new fixtures if no equivalent exists in `conftest.py`
   - Document any new fixtures added to `conftest.py`

3. **Test Method Organization**
   - Order test methods in the following sequence:
     1. Basic functionality tests
     2. Parameter validation tests
     3. Error handling tests
     4. Edge case tests
   - Group related tests together
   - Use consistent naming pattern within each group
   - Keep test methods focused and single-purpose

4. **Test Conventions**
   - Follow the established test naming conventions
   - Include proper test docstrings
   - Group related tests in appropriate test classes
   - Use descriptive test names that explain the test case

### Model Tests
When writing tests for models, follow the structure in `DevContainerComposer/tests/models/test_expose_feature.py`:
- Test class must use pytest
- Test all model methods
- Test property validation
- Test edge cases
- Include proper test docstrings
- Follow the established test naming conventions

## General Guidelines
1. Always maintain consistency with existing code patterns
2. Follow the established project structure
3. Use the gold source files as reference for implementation
4. Ensure all new code includes proper documentation
5. Maintain consistent error handling patterns
6. Follow the established naming conventions
7. Use type hints consistently
8. Implement proper validation for all inputs
9. Write comprehensive tests for all new functionality

## Reference Files
- Command implementation: `DevContainerComposer/compose/commands/expose.py`
- Model implementation: `DevContainerComposer/compose/models.py`
- Command tests: `DevContainerComposer/tests/commands/test_expose.py`
- Model tests: `DevContainerComposer/tests/models/test_expose_feature.py`
- Test fixtures: `DevContainerComposer/tests/conftest.py`
